{"version":3,"sources":["webpack://app/./node_modules/@hat-core/renderer/index.js","webpack://app/./node_modules/snabbdom/build/package/init.js","webpack://app/./node_modules/snabbdom/build/package/vnode.js","webpack://app/./node_modules/snabbdom/build/package/is.js","webpack://app/./node_modules/snabbdom/build/package/htmldomapi.js","webpack://app/./node_modules/snabbdom/build/package/h.js","webpack://app/./node_modules/snabbdom/build/package/modules/class.js","webpack://app/./node_modules/snabbdom/build/package/modules/dataset.js","webpack://app/./node_modules/snabbdom/build/package/modules/eventlisteners.js","webpack://app/./node_modules/snabbdom/build/package/modules/style.js","webpack://app/./node_modules/@hat-core/util/index.js","webpack://app/webpack/bootstrap","webpack://app/webpack/runtime/define property getters","webpack://app/webpack/runtime/hasOwnProperty shorthand","webpack://app/webpack/runtime/make namespace object","webpack://app/./modules/index.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;AACA;;AAEmD;AACT;AAC0B;AACM;AACY;AAClB;;AAEhC;;;AAGpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,CAAC;;;AAGD,cAAc,mDAAY;AAC1B;AACA,IAAI,+DAAa;AACjB;AACA,IAAI,mEAAe;AACnB,IAAI,iFAAa;AACjB;;;AAGA;AACA;AACA;AACA,QAAQ,oDAAU;AAClB;AACA,SAAS,mDAAS;AAClB;AACA;AACA;AACA;AACA;AACA,uCAAuC,oDAAU;AACjD,qBAAqB,gDAAM;AAC3B,QAAQ,+CAAK;AACb,QAAQ,mDAAS;AACjB;AACA;AACA;AACA,QAAQ,6CAAS;AACjB,QAAQ,6CAAS;AACjB;AACA;;AAEA;AACA;AACA;AACO;;AAEP;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,IAAI;AACnB,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,IAAI;AACnB,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAU;AACjC;AACA;AACA;AACA,uCAAuC,WAAW,EAAE;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,oBAAoB;AAC1E;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB;AAChB;AACA;AACA,eAAe,+CAAK;AACpB;;AAEA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,IAAI;AACnB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,SAAS;AACxB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB,+CAAK;AAC9B;AACA,0BAA0B,kDAAQ;AAClC,+BAA+B,kDAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,2CAA2C,oBAAoB;AAC/D;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,iEAAe,eAAe,EAAC;;;;;;;;;;;;;;AClQI;AACL;AACe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gDAAK,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,sDAAU;AAC1D,eAAe,kBAAkB;AACjC;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gDAAK,4CAA4C;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA,gBAAgB,yCAAQ;AACxB,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6CAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA,+BAA+B,2BAA2B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uBAAuB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+BAA+B;AAClD;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA,gC;;;;;;;;;;AChUO;AACP;AACA,YAAY;AACZ;AACA,iC;;;;;;;;;;;ACJO;AACA;AACP;AACA;AACA,8B;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;;;;;;AC9DmC;AACL;AAC9B;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yCAAQ;AACpB;AACA;AACA,iBAAiB,6CAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yCAAQ;AACpB;AACA;AACA,iBAAiB,6CAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC,gBAAgB,6CAAY;AAC5B,8BAA8B,gDAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gDAAK;AAChB;AACA;AACA,6B;;;;;;;;;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,qBAAqB;AAC5B,iC;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,uBAAuB;AAC9B,mC;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,0C;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,kBAAkB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,uBAAuB;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY,EAAE;AACd;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,UAAU;AACV;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,IAAI;AACf,UAAU;AACV;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY,EAAE;AACd;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,YAAY;AACZ;AACO;AACP;AACA,uBAAuB,oCAAoC;AAC3D;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,YAAY;AACZ;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,OAAO;AAClB,YAAY;AACZ;AACO,2CAA2C,UAAU;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,EAAE;AACb,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,+CAA+C,SAAS;AACxD,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,EAAE;AACb,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA,SAAS;AACT,+CAA+C,SAAS;AACxD,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,EAAE;AACb,YAAY;AACZ;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,MAAM;AACjB,YAAY;AACZ;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,MAAM;AACjB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,UAAU,YAAY,UAAU,KAAK;AAC3D,WAAW,SAAS;AACpB,WAAW,aAAa;AACxB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,MAAM;AACjB,YAAY;AACZ;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,MAAM;AACjB,YAAY;AACZ;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,WAAW,MAAM;AACjB,YAAY,EAAE;AACd;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACO,8CAA8C;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,YAAY;AACZ;AACO,iCAAiC;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,UAAU,kBAAkB,UAAU;AAC5D,WAAW,SAAS;AACpB,WAAW,aAAa;AACxB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,UAAU,kBAAkB,UAAU;AAC5D,WAAW,SAAS;AACpB,WAAW,aAAa;AACxB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,YAAY;AACZ;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,aAAa;AACxB,YAAY;AACZ;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,EAAE;AACb,WAAW,MAAM;AACjB,YAAY;AACZ;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,YAAY;AACZ;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY;AACZ;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY;AACZ;AACO;AACP;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY;AACZ;AACO;AACP;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY;AACZ;AACO;AACP;AACA;;AAEA;AACA;AACA,YAAY,IAAI;AAChB,YAAY;AACZ;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACO;AACP;AACA,0BAA0B,WAAW,EAAE;AACvC,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb,YAAY;AACZ;AACO;AACP;AACA,0BAA0B,sBAAsB,EAAE;AAClD,KAAK;AACL;;;;;;UC/0BA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCrBA;WACA;WACA;WACA;WACA,wCAAwC,yCAAyC;WACjF;WACA;WACA,E;;;;;WCPA,wF;;;;;WCAA;WACA;WACA;WACA,sDAAsD,kBAAkB;WACxE;WACA,+CAA+C,cAAc;WAC7D,E;;;;;;;;;;;;;;ACNmC;;;AAG5B;AACP,UAAU,2DAAK,WAAW;AAC1B;;;AAGO;AACP;AACA;;;AAGO","file":"index.js","sourcesContent":["/** @module @hat-core/renderer\n */\n\nimport {init as snabbdomInit} from 'snabbdom/init';\nimport {h as snabbdomH} from 'snabbdom/h';\nimport {classModule as snabbdomClass} from 'snabbdom/modules/class';\nimport {datasetModule as snabbdomDataset} from 'snabbdom/modules/dataset';\nimport {eventListenersModule as snabbdomEvent} from 'snabbdom/modules/eventlisteners';\nimport {styleModule as snabbdomStyle} from 'snabbdom/modules/style';\n\nimport * as u from '@hat-core/util';\n\n\n// patched version of snabbdom's es/modules/attributes.js\nconst snabbdomAttributes = (() => {\n    function updateAttrs(oldVnode, vnode) {\n        var key, elm = vnode.elm, oldAttrs = oldVnode.data.attrs, attrs = vnode.data.attrs;\n        if (!oldAttrs && !attrs)\n            return;\n        if (oldAttrs === attrs)\n            return;\n        oldAttrs = oldAttrs || {};\n        attrs = attrs || {};\n        for (key in attrs) {\n            var cur = attrs[key];\n            var old = oldAttrs[key];\n            if (old !== cur) {\n                if (cur === true) {\n                    elm.setAttribute(key, \"\");\n                }\n                else if (cur === false) {\n                    elm.removeAttribute(key);\n                }\n                else {\n                    elm.setAttribute(key, cur);\n                }\n            }\n        }\n        for (key in oldAttrs) {\n            if (!(key in attrs)) {\n                elm.removeAttribute(key);\n            }\n        }\n    }\n    return { create: updateAttrs, update: updateAttrs };\n})();\n\n\n// patched version of snabbdom's es/modules/props.js\nconst snabbdomProps = (() => {\n    function updateProps(oldVnode, vnode) {\n        var key, cur, old, elm = vnode.elm, oldProps = oldVnode.data.props, props = vnode.data.props;\n        if (!oldProps && !props)\n            return;\n        if (oldProps === props)\n            return;\n        oldProps = oldProps || {};\n        props = props || {};\n        for (key in oldProps) {\n            if (!props[key]) {\n                if (key === 'style') {\n                    elm[key] = '';\n                } else {\n                    delete elm[key];\n                }\n            }\n        }\n        for (key in props) {\n            cur = props[key];\n            old = oldProps[key];\n            if (old !== cur && (key !== 'value' || elm[key] !== cur)) {\n                elm[key] = cur;\n            }\n        }\n    }\n    return { create: updateProps, update: updateProps };\n})();\n\n\nconst patch = snabbdomInit([\n    snabbdomAttributes,\n    snabbdomClass,\n    snabbdomProps,\n    snabbdomDataset,\n    snabbdomEvent\n]);\n\n\nfunction vhFromArray(node) {\n    if (!node)\n        return [];\n    if (u.isString(node))\n        return node;\n    if (!u.isArray(node))\n        throw 'Invalid node structure';\n    if (node.length < 1)\n        return [];\n    if (typeof node[0] != 'string')\n        return node.map(vhFromArray);\n    const hasData = node.length > 1 && u.isObject(node[1]);\n    const children = u.pipe(\n        u.map(vhFromArray),\n        u.flatten,\n        Array.from\n    )(node.slice(hasData ? 2 : 1));\n    const result = hasData ?\n        snabbdomH(node[0], node[1], children) :\n        snabbdomH(node[0], children);\n    return result;\n}\n\n/**\n * Virtual DOM renderer\n */\nexport class Renderer extends EventTarget {\n\n    /**\n     * Calls `init` method\n     * @param {HTMLElement} [el=document.body]\n     * @param {Any} [initState=null]\n     * @param {Function} [vtCb=null]\n     * @param {Number} [maxFps=30]\n     */\n    constructor(el, initState, vtCb, maxFps) {\n        super();\n        this.init(el, initState, vtCb, maxFps);\n    }\n\n    /**\n     * Initialize renderer\n     * @param {HTMLElement} [el=document.body]\n     * @param {Any} [initState=null]\n     * @param {Function} [vtCb=null]\n     * @param {Number} [maxFps=30]\n     * @return {Promise}\n     */\n    init(el, initState, vtCb, maxFps) {\n        this._state = null;\n        this._changes = [];\n        this._promise = null;\n        this._timeout = null;\n        this._lastRender = null;\n        this._vtCb = vtCb;\n        this._maxFps = u.isNumber(maxFps) ? maxFps : 30;\n        this._vNode = el || document.querySelector('body');\n        if (initState)\n            return this.change(_ => initState);\n        return new Promise(resolve => { resolve(); });\n    }\n\n    /**\n      * Render\n      */\n    render() {\n        if (!this._vtCb)\n            return;\n        this._lastRender = performance.now();\n        const vNode = vhFromArray(this._vtCb(this));\n        patch(this._vNode, vNode);\n        this._vNode = vNode;\n        this.dispatchEvent(new CustomEvent('render', {detail: this._state}));\n    }\n\n    /**\n     * Get current state value referenced by `paths`\n     * @param {...Path} paths\n     * @return {Any}\n     */\n    get(...paths) {\n        return u.get(paths, this._state);\n    }\n\n    /**\n     * Change current state value referenced by `path`\n     * @param {Path} path\n     * @param {Any} value\n     * @return {Promise}\n     */\n    set(path, value) {\n        if (arguments.length < 2) {\n            value = path;\n            path = [];\n        }\n        return this.change(path, _ => value);\n    }\n\n    /**\n     * Change current state value referenced by `path`\n     * @param {Path} path\n     * @param {Function} cb\n     * @return {Promise}\n     */\n    change(path, cb) {\n        if (arguments.length < 2) {\n            cb = path;\n            path = [];\n        }\n        this._changes.push([path, cb]);\n        if (this._promise)\n            return this._promise;\n        this._promise = new Promise((resolve, reject) => {\n            setTimeout(() => {\n                try {\n                    this._change();\n                } catch(e) {\n                    this._promise = null;\n                    reject(e);\n                    throw e;\n                }\n                this._promise = null;\n                resolve();\n            }, 0);\n        });\n        return this._promise;\n    }\n\n    _change() {\n        let change = false;\n        while (this._changes.length > 0) {\n            const [path, cb] = this._changes.shift();\n            const view = u.get(path);\n            const oldState = this._state;\n            this._state = u.change(path, cb, this._state);\n            if (this._state && u.equals(view(oldState),\n                                        view(this._state)))\n                continue;\n            change = true;\n            if (!this._vtCb || this._timeout)\n                continue;\n            const delay = (!this._lastRender || !this._maxFps ?\n                0 :\n                (1000 / this._maxFps) -\n                (performance.now() - this._lastRender));\n            this._timeout = setTimeout(() => {\n                this._timeout = null;\n                this.render();\n            }, (delay > 0 ? delay : 0));\n        }\n        if (change)\n            this.dispatchEvent(\n                new CustomEvent('change', {detail: this._state}));\n    }\n}\n// Renderer.prototype.set = u.curry(Renderer.prototype.set);\n// Renderer.prototype.change = u.curry(Renderer.prototype.change);\n\n\n/**\n * Default renderer\n * @static\n * @type {Renderer}\n */\nconst defaultRenderer = (() => {\n    const r = (window && window.__hat_default_renderer) || new Renderer();\n    if (window)\n        window.__hat_default_renderer = r;\n    return r;\n})();\nexport default defaultRenderer;\n","import { vnode } from \"./vnode.js\";\nimport * as is from \"./is.js\";\nimport { htmlDomApi } from \"./htmldomapi.js\";\nfunction isUndef(s) {\n    return s === undefined;\n}\nfunction isDef(s) {\n    return s !== undefined;\n}\nconst emptyNode = vnode('', {}, [], undefined, undefined);\nfunction sameVnode(vnode1, vnode2) {\n    return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;\n}\nfunction isVnode(vnode) {\n    return vnode.sel !== undefined;\n}\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n    var _a;\n    const map = {};\n    for (let i = beginIdx; i <= endIdx; ++i) {\n        const key = (_a = children[i]) === null || _a === void 0 ? void 0 : _a.key;\n        if (key !== undefined) {\n            map[key] = i;\n        }\n    }\n    return map;\n}\nconst hooks = ['create', 'update', 'remove', 'destroy', 'pre', 'post'];\nexport function init(modules, domApi) {\n    let i;\n    let j;\n    const cbs = {\n        create: [],\n        update: [],\n        remove: [],\n        destroy: [],\n        pre: [],\n        post: []\n    };\n    const api = domApi !== undefined ? domApi : htmlDomApi;\n    for (i = 0; i < hooks.length; ++i) {\n        cbs[hooks[i]] = [];\n        for (j = 0; j < modules.length; ++j) {\n            const hook = modules[j][hooks[i]];\n            if (hook !== undefined) {\n                cbs[hooks[i]].push(hook);\n            }\n        }\n    }\n    function emptyNodeAt(elm) {\n        const id = elm.id ? '#' + elm.id : '';\n        const c = elm.className ? '.' + elm.className.split(' ').join('.') : '';\n        return vnode(api.tagName(elm).toLowerCase() + id + c, {}, [], undefined, elm);\n    }\n    function createRmCb(childElm, listeners) {\n        return function rmCb() {\n            if (--listeners === 0) {\n                const parent = api.parentNode(childElm);\n                api.removeChild(parent, childElm);\n            }\n        };\n    }\n    function createElm(vnode, insertedVnodeQueue) {\n        var _a, _b;\n        let i;\n        let data = vnode.data;\n        if (data !== undefined) {\n            const init = (_a = data.hook) === null || _a === void 0 ? void 0 : _a.init;\n            if (isDef(init)) {\n                init(vnode);\n                data = vnode.data;\n            }\n        }\n        const children = vnode.children;\n        const sel = vnode.sel;\n        if (sel === '!') {\n            if (isUndef(vnode.text)) {\n                vnode.text = '';\n            }\n            vnode.elm = api.createComment(vnode.text);\n        }\n        else if (sel !== undefined) {\n            // Parse selector\n            const hashIdx = sel.indexOf('#');\n            const dotIdx = sel.indexOf('.', hashIdx);\n            const hash = hashIdx > 0 ? hashIdx : sel.length;\n            const dot = dotIdx > 0 ? dotIdx : sel.length;\n            const tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;\n            const elm = vnode.elm = isDef(data) && isDef(i = data.ns)\n                ? api.createElementNS(i, tag)\n                : api.createElement(tag);\n            if (hash < dot)\n                elm.setAttribute('id', sel.slice(hash + 1, dot));\n            if (dotIdx > 0)\n                elm.setAttribute('class', sel.slice(dot + 1).replace(/\\./g, ' '));\n            for (i = 0; i < cbs.create.length; ++i)\n                cbs.create[i](emptyNode, vnode);\n            if (is.array(children)) {\n                for (i = 0; i < children.length; ++i) {\n                    const ch = children[i];\n                    if (ch != null) {\n                        api.appendChild(elm, createElm(ch, insertedVnodeQueue));\n                    }\n                }\n            }\n            else if (is.primitive(vnode.text)) {\n                api.appendChild(elm, api.createTextNode(vnode.text));\n            }\n            const hook = vnode.data.hook;\n            if (isDef(hook)) {\n                (_b = hook.create) === null || _b === void 0 ? void 0 : _b.call(hook, emptyNode, vnode);\n                if (hook.insert) {\n                    insertedVnodeQueue.push(vnode);\n                }\n            }\n        }\n        else {\n            vnode.elm = api.createTextNode(vnode.text);\n        }\n        return vnode.elm;\n    }\n    function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n        for (; startIdx <= endIdx; ++startIdx) {\n            const ch = vnodes[startIdx];\n            if (ch != null) {\n                api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);\n            }\n        }\n    }\n    function invokeDestroyHook(vnode) {\n        var _a, _b;\n        const data = vnode.data;\n        if (data !== undefined) {\n            (_b = (_a = data === null || data === void 0 ? void 0 : data.hook) === null || _a === void 0 ? void 0 : _a.destroy) === null || _b === void 0 ? void 0 : _b.call(_a, vnode);\n            for (let i = 0; i < cbs.destroy.length; ++i)\n                cbs.destroy[i](vnode);\n            if (vnode.children !== undefined) {\n                for (let j = 0; j < vnode.children.length; ++j) {\n                    const child = vnode.children[j];\n                    if (child != null && typeof child !== 'string') {\n                        invokeDestroyHook(child);\n                    }\n                }\n            }\n        }\n    }\n    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n        var _a, _b;\n        for (; startIdx <= endIdx; ++startIdx) {\n            let listeners;\n            let rm;\n            const ch = vnodes[startIdx];\n            if (ch != null) {\n                if (isDef(ch.sel)) {\n                    invokeDestroyHook(ch);\n                    listeners = cbs.remove.length + 1;\n                    rm = createRmCb(ch.elm, listeners);\n                    for (let i = 0; i < cbs.remove.length; ++i)\n                        cbs.remove[i](ch, rm);\n                    const removeHook = (_b = (_a = ch === null || ch === void 0 ? void 0 : ch.data) === null || _a === void 0 ? void 0 : _a.hook) === null || _b === void 0 ? void 0 : _b.remove;\n                    if (isDef(removeHook)) {\n                        removeHook(ch, rm);\n                    }\n                    else {\n                        rm();\n                    }\n                }\n                else { // Text node\n                    api.removeChild(parentElm, ch.elm);\n                }\n            }\n        }\n    }\n    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {\n        let oldStartIdx = 0;\n        let newStartIdx = 0;\n        let oldEndIdx = oldCh.length - 1;\n        let oldStartVnode = oldCh[0];\n        let oldEndVnode = oldCh[oldEndIdx];\n        let newEndIdx = newCh.length - 1;\n        let newStartVnode = newCh[0];\n        let newEndVnode = newCh[newEndIdx];\n        let oldKeyToIdx;\n        let idxInOld;\n        let elmToMove;\n        let before;\n        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n            if (oldStartVnode == null) {\n                oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left\n            }\n            else if (oldEndVnode == null) {\n                oldEndVnode = oldCh[--oldEndIdx];\n            }\n            else if (newStartVnode == null) {\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else if (newEndVnode == null) {\n                newEndVnode = newCh[--newEndIdx];\n            }\n            else if (sameVnode(oldStartVnode, newStartVnode)) {\n                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n                oldStartVnode = oldCh[++oldStartIdx];\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else if (sameVnode(oldEndVnode, newEndVnode)) {\n                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n                oldEndVnode = oldCh[--oldEndIdx];\n                newEndVnode = newCh[--newEndIdx];\n            }\n            else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n                api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));\n                oldStartVnode = oldCh[++oldStartIdx];\n                newEndVnode = newCh[--newEndIdx];\n            }\n            else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n                api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n                oldEndVnode = oldCh[--oldEndIdx];\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else {\n                if (oldKeyToIdx === undefined) {\n                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n                }\n                idxInOld = oldKeyToIdx[newStartVnode.key];\n                if (isUndef(idxInOld)) { // New element\n                    api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n                }\n                else {\n                    elmToMove = oldCh[idxInOld];\n                    if (elmToMove.sel !== newStartVnode.sel) {\n                        api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n                    }\n                    else {\n                        patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n                        oldCh[idxInOld] = undefined;\n                        api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);\n                    }\n                }\n                newStartVnode = newCh[++newStartIdx];\n            }\n        }\n        if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {\n            if (oldStartIdx > oldEndIdx) {\n                before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;\n                addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n            }\n            else {\n                removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n            }\n        }\n    }\n    function patchVnode(oldVnode, vnode, insertedVnodeQueue) {\n        var _a, _b, _c, _d, _e;\n        const hook = (_a = vnode.data) === null || _a === void 0 ? void 0 : _a.hook;\n        (_b = hook === null || hook === void 0 ? void 0 : hook.prepatch) === null || _b === void 0 ? void 0 : _b.call(hook, oldVnode, vnode);\n        const elm = vnode.elm = oldVnode.elm;\n        const oldCh = oldVnode.children;\n        const ch = vnode.children;\n        if (oldVnode === vnode)\n            return;\n        if (vnode.data !== undefined) {\n            for (let i = 0; i < cbs.update.length; ++i)\n                cbs.update[i](oldVnode, vnode);\n            (_d = (_c = vnode.data.hook) === null || _c === void 0 ? void 0 : _c.update) === null || _d === void 0 ? void 0 : _d.call(_c, oldVnode, vnode);\n        }\n        if (isUndef(vnode.text)) {\n            if (isDef(oldCh) && isDef(ch)) {\n                if (oldCh !== ch)\n                    updateChildren(elm, oldCh, ch, insertedVnodeQueue);\n            }\n            else if (isDef(ch)) {\n                if (isDef(oldVnode.text))\n                    api.setTextContent(elm, '');\n                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n            }\n            else if (isDef(oldCh)) {\n                removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n            }\n            else if (isDef(oldVnode.text)) {\n                api.setTextContent(elm, '');\n            }\n        }\n        else if (oldVnode.text !== vnode.text) {\n            if (isDef(oldCh)) {\n                removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n            }\n            api.setTextContent(elm, vnode.text);\n        }\n        (_e = hook === null || hook === void 0 ? void 0 : hook.postpatch) === null || _e === void 0 ? void 0 : _e.call(hook, oldVnode, vnode);\n    }\n    return function patch(oldVnode, vnode) {\n        let i, elm, parent;\n        const insertedVnodeQueue = [];\n        for (i = 0; i < cbs.pre.length; ++i)\n            cbs.pre[i]();\n        if (!isVnode(oldVnode)) {\n            oldVnode = emptyNodeAt(oldVnode);\n        }\n        if (sameVnode(oldVnode, vnode)) {\n            patchVnode(oldVnode, vnode, insertedVnodeQueue);\n        }\n        else {\n            elm = oldVnode.elm;\n            parent = api.parentNode(elm);\n            createElm(vnode, insertedVnodeQueue);\n            if (parent !== null) {\n                api.insertBefore(parent, vnode.elm, api.nextSibling(elm));\n                removeVnodes(parent, [oldVnode], 0, 0);\n            }\n        }\n        for (i = 0; i < insertedVnodeQueue.length; ++i) {\n            insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);\n        }\n        for (i = 0; i < cbs.post.length; ++i)\n            cbs.post[i]();\n        return vnode;\n    };\n}\n//# sourceMappingURL=init.js.map","export function vnode(sel, data, children, text, elm) {\n    const key = data === undefined ? undefined : data.key;\n    return { sel, data, children, text, elm, key };\n}\n//# sourceMappingURL=vnode.js.map","export const array = Array.isArray;\nexport function primitive(s) {\n    return typeof s === 'string' || typeof s === 'number';\n}\n//# sourceMappingURL=is.js.map","function createElement(tagName) {\n    return document.createElement(tagName);\n}\nfunction createElementNS(namespaceURI, qualifiedName) {\n    return document.createElementNS(namespaceURI, qualifiedName);\n}\nfunction createTextNode(text) {\n    return document.createTextNode(text);\n}\nfunction createComment(text) {\n    return document.createComment(text);\n}\nfunction insertBefore(parentNode, newNode, referenceNode) {\n    parentNode.insertBefore(newNode, referenceNode);\n}\nfunction removeChild(node, child) {\n    node.removeChild(child);\n}\nfunction appendChild(node, child) {\n    node.appendChild(child);\n}\nfunction parentNode(node) {\n    return node.parentNode;\n}\nfunction nextSibling(node) {\n    return node.nextSibling;\n}\nfunction tagName(elm) {\n    return elm.tagName;\n}\nfunction setTextContent(node, text) {\n    node.textContent = text;\n}\nfunction getTextContent(node) {\n    return node.textContent;\n}\nfunction isElement(node) {\n    return node.nodeType === 1;\n}\nfunction isText(node) {\n    return node.nodeType === 3;\n}\nfunction isComment(node) {\n    return node.nodeType === 8;\n}\nexport const htmlDomApi = {\n    createElement,\n    createElementNS,\n    createTextNode,\n    createComment,\n    insertBefore,\n    removeChild,\n    appendChild,\n    parentNode,\n    nextSibling,\n    tagName,\n    setTextContent,\n    getTextContent,\n    isElement,\n    isText,\n    isComment,\n};\n//# sourceMappingURL=htmldomapi.js.map","import { vnode } from \"./vnode.js\";\nimport * as is from \"./is.js\";\nfunction addNS(data, children, sel) {\n    data.ns = 'http://www.w3.org/2000/svg';\n    if (sel !== 'foreignObject' && children !== undefined) {\n        for (let i = 0; i < children.length; ++i) {\n            const childData = children[i].data;\n            if (childData !== undefined) {\n                addNS(childData, children[i].children, children[i].sel);\n            }\n        }\n    }\n}\nexport function h(sel, b, c) {\n    var data = {};\n    var children;\n    var text;\n    var i;\n    if (c !== undefined) {\n        if (b !== null) {\n            data = b;\n        }\n        if (is.array(c)) {\n            children = c;\n        }\n        else if (is.primitive(c)) {\n            text = c;\n        }\n        else if (c && c.sel) {\n            children = [c];\n        }\n    }\n    else if (b !== undefined && b !== null) {\n        if (is.array(b)) {\n            children = b;\n        }\n        else if (is.primitive(b)) {\n            text = b;\n        }\n        else if (b && b.sel) {\n            children = [b];\n        }\n        else {\n            data = b;\n        }\n    }\n    if (children !== undefined) {\n        for (i = 0; i < children.length; ++i) {\n            if (is.primitive(children[i]))\n                children[i] = vnode(undefined, undefined, undefined, children[i], undefined);\n        }\n    }\n    if (sel[0] === 's' && sel[1] === 'v' && sel[2] === 'g' &&\n        (sel.length === 3 || sel[3] === '.' || sel[3] === '#')) {\n        addNS(data, children, sel);\n    }\n    return vnode(sel, data, children, text, undefined);\n}\n;\n//# sourceMappingURL=h.js.map","function updateClass(oldVnode, vnode) {\n    var cur;\n    var name;\n    var elm = vnode.elm;\n    var oldClass = oldVnode.data.class;\n    var klass = vnode.data.class;\n    if (!oldClass && !klass)\n        return;\n    if (oldClass === klass)\n        return;\n    oldClass = oldClass || {};\n    klass = klass || {};\n    for (name in oldClass) {\n        if (oldClass[name] &&\n            !Object.prototype.hasOwnProperty.call(klass, name)) {\n            // was `true` and now not provided\n            elm.classList.remove(name);\n        }\n    }\n    for (name in klass) {\n        cur = klass[name];\n        if (cur !== oldClass[name]) {\n            elm.classList[cur ? 'add' : 'remove'](name);\n        }\n    }\n}\nexport const classModule = { create: updateClass, update: updateClass };\n//# sourceMappingURL=class.js.map","const CAPS_REGEX = /[A-Z]/g;\nfunction updateDataset(oldVnode, vnode) {\n    const elm = vnode.elm;\n    let oldDataset = oldVnode.data.dataset;\n    let dataset = vnode.data.dataset;\n    let key;\n    if (!oldDataset && !dataset)\n        return;\n    if (oldDataset === dataset)\n        return;\n    oldDataset = oldDataset || {};\n    dataset = dataset || {};\n    const d = elm.dataset;\n    for (key in oldDataset) {\n        if (!dataset[key]) {\n            if (d) {\n                if (key in d) {\n                    delete d[key];\n                }\n            }\n            else {\n                elm.removeAttribute('data-' + key.replace(CAPS_REGEX, '-$&').toLowerCase());\n            }\n        }\n    }\n    for (key in dataset) {\n        if (oldDataset[key] !== dataset[key]) {\n            if (d) {\n                d[key] = dataset[key];\n            }\n            else {\n                elm.setAttribute('data-' + key.replace(CAPS_REGEX, '-$&').toLowerCase(), dataset[key]);\n            }\n        }\n    }\n}\nexport const datasetModule = { create: updateDataset, update: updateDataset };\n//# sourceMappingURL=dataset.js.map","function invokeHandler(handler, vnode, event) {\n    if (typeof handler === 'function') {\n        // call function handler\n        handler.call(vnode, event, vnode);\n    }\n    else if (typeof handler === 'object') {\n        // call multiple handlers\n        for (var i = 0; i < handler.length; i++) {\n            invokeHandler(handler[i], vnode, event);\n        }\n    }\n}\nfunction handleEvent(event, vnode) {\n    var name = event.type;\n    var on = vnode.data.on;\n    // call event handler(s) if exists\n    if (on && on[name]) {\n        invokeHandler(on[name], vnode, event);\n    }\n}\nfunction createListener() {\n    return function handler(event) {\n        handleEvent(event, handler.vnode);\n    };\n}\nfunction updateEventListeners(oldVnode, vnode) {\n    var oldOn = oldVnode.data.on;\n    var oldListener = oldVnode.listener;\n    var oldElm = oldVnode.elm;\n    var on = vnode && vnode.data.on;\n    var elm = (vnode && vnode.elm);\n    var name;\n    // optimization for reused immutable handlers\n    if (oldOn === on) {\n        return;\n    }\n    // remove existing listeners which no longer used\n    if (oldOn && oldListener) {\n        // if element changed or deleted we remove all existing listeners unconditionally\n        if (!on) {\n            for (name in oldOn) {\n                // remove listener if element was changed or existing listeners removed\n                oldElm.removeEventListener(name, oldListener, false);\n            }\n        }\n        else {\n            for (name in oldOn) {\n                // remove listener if existing listener removed\n                if (!on[name]) {\n                    oldElm.removeEventListener(name, oldListener, false);\n                }\n            }\n        }\n    }\n    // add new listeners which has not already attached\n    if (on) {\n        // reuse existing listener or create new\n        var listener = vnode.listener = oldVnode.listener || createListener();\n        // update vnode for listener\n        listener.vnode = vnode;\n        // if element changed or added we add all needed listeners unconditionally\n        if (!oldOn) {\n            for (name in on) {\n                // add listener if element was changed or new listeners added\n                elm.addEventListener(name, listener, false);\n            }\n        }\n        else {\n            for (name in on) {\n                // add listener if new listener added\n                if (!oldOn[name]) {\n                    elm.addEventListener(name, listener, false);\n                }\n            }\n        }\n    }\n}\nexport const eventListenersModule = {\n    create: updateEventListeners,\n    update: updateEventListeners,\n    destroy: updateEventListeners\n};\n//# sourceMappingURL=eventlisteners.js.map","// Bindig `requestAnimationFrame` like this fixes a bug in IE/Edge. See #360 and #409.\nvar raf = (typeof window !== 'undefined' && (window.requestAnimationFrame).bind(window)) || setTimeout;\nvar nextFrame = function (fn) {\n    raf(function () {\n        raf(fn);\n    });\n};\nvar reflowForced = false;\nfunction setNextFrame(obj, prop, val) {\n    nextFrame(function () {\n        obj[prop] = val;\n    });\n}\nfunction updateStyle(oldVnode, vnode) {\n    var cur;\n    var name;\n    var elm = vnode.elm;\n    var oldStyle = oldVnode.data.style;\n    var style = vnode.data.style;\n    if (!oldStyle && !style)\n        return;\n    if (oldStyle === style)\n        return;\n    oldStyle = oldStyle || {};\n    style = style || {};\n    var oldHasDel = 'delayed' in oldStyle;\n    for (name in oldStyle) {\n        if (!style[name]) {\n            if (name[0] === '-' && name[1] === '-') {\n                elm.style.removeProperty(name);\n            }\n            else {\n                elm.style[name] = '';\n            }\n        }\n    }\n    for (name in style) {\n        cur = style[name];\n        if (name === 'delayed' && style.delayed) {\n            for (const name2 in style.delayed) {\n                cur = style.delayed[name2];\n                if (!oldHasDel || cur !== oldStyle.delayed[name2]) {\n                    setNextFrame(elm.style, name2, cur);\n                }\n            }\n        }\n        else if (name !== 'remove' && cur !== oldStyle[name]) {\n            if (name[0] === '-' && name[1] === '-') {\n                elm.style.setProperty(name, cur);\n            }\n            else {\n                elm.style[name] = cur;\n            }\n        }\n    }\n}\nfunction applyDestroyStyle(vnode) {\n    var style;\n    var name;\n    var elm = vnode.elm;\n    var s = vnode.data.style;\n    if (!s || !(style = s.destroy))\n        return;\n    for (name in style) {\n        elm.style[name] = style[name];\n    }\n}\nfunction applyRemoveStyle(vnode, rm) {\n    var s = vnode.data.style;\n    if (!s || !s.remove) {\n        rm();\n        return;\n    }\n    if (!reflowForced) {\n        // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n        vnode.elm.offsetLeft;\n        reflowForced = true;\n    }\n    var name;\n    var elm = vnode.elm;\n    var i = 0;\n    var compStyle;\n    var style = s.remove;\n    var amount = 0;\n    var applied = [];\n    for (name in style) {\n        applied.push(name);\n        elm.style[name] = style[name];\n    }\n    compStyle = getComputedStyle(elm);\n    var props = compStyle['transition-property'].split(', ');\n    for (; i < props.length; ++i) {\n        if (applied.indexOf(props[i]) !== -1)\n            amount++;\n    }\n    elm.addEventListener('transitionend', function (ev) {\n        if (ev.target === elm)\n            --amount;\n        if (amount === 0)\n            rm();\n    });\n}\nfunction forceReflow() {\n    reflowForced = false;\n}\nexport const styleModule = {\n    pre: forceReflow,\n    create: updateStyle,\n    update: updateStyle,\n    destroy: applyDestroyStyle,\n    remove: applyRemoveStyle\n};\n//# sourceMappingURL=style.js.map","/**\n * Utility library for manipulation of JSON data.\n *\n * Main characteristics:\n *   - input/output data types are limited to JSON data, functions and\n *     `undefined` (sparse arrays and complex objects with prototype chain are\n *     not supported)\n *   - functional API with curried functions (similar to ramdajs)\n *   - implementation based on natively supported browser JS API\n *   - scope limited to most used functions in hat projects\n *   - usage of `paths` instead of `lenses`\n *\n * TODO: define convetion for naming arguments based on their type and\n *       semantics\n *\n * @module @hat-core/util\n */\n\n/**\n * Path can be an object property name, array index, or array of Paths\n *\n * TODO: explain paths and path compositions (include examples)\n *\n * @typedef {(String|Number|Path[])} module:@hat-core/util.Path\n */\n\n/**\n * Identity function returning same value provided as argument.\n *\n * @function\n * @sig a -> a\n * @param {*} x input value\n * @return {*} same value as input\n */\nexport const identity = x => x;\n\n/**\n * Check if value is `null` or `undefined`.\n *\n * For same argument, if this function returns `true`, functions `isBoolean`,\n * `isInteger`, `isNumber`, `isString`, `isArray` and `isObject` will return\n * `false`.\n *\n * @function\n * @sig * -> Boolean\n * @param {*} x input value\n * @return {Boolean}\n */\nexport const isNil = x => x == null;\n\n/**\n * Check if value is Boolean.\n *\n * For same argument, if this function returns `true`, functions `isNil`,\n * `isInteger`, `isNumber`, `isString`, `isArray` and `isObject` will return\n * `false`.\n *\n * @function\n * @sig * -> Boolean\n * @param {*} x input value\n * @return {Boolean}\n */\nexport const isBoolean = x => typeof(x) == 'boolean';\n\n/**\n * Check if value is Integer.\n *\n * For same argument, if this function returns `true`, function `isNumber` will\n * also return `true`.\n *\n * For same argument, if this function returns `true`, functions `isNil`,\n * `isBoolean`, `isString`, `isArray` and `isObject` will return `false`.\n *\n * @function\n * @sig * -> Boolean\n * @param {*} x input value\n * @type {Boolean}\n */\nexport const isInteger = Number.isInteger;\n\n/**\n * Check if value is Number.\n *\n * For same argument, if this function returns `true`, function `isInteger` may\n * also return `true` if argument is integer number.\n *\n * For same argument, if this function returns `true`, functions `isNil`,\n * `isBoolean`, `isString`, `isArray` and `isObject` will return `false`.\n *\n * @function\n * @sig * -> Boolean\n * @param {*} x input value\n * @return {Boolean}\n */\nexport const isNumber = x => typeof(x) == 'number';\n\n/**\n * Check if value is String.\n *\n * For same argument, if this function returns `true`, functions `isNil`,\n * `isBoolean`, `isInteger`, `isNumber`, `isArray`, and `isObject` will return\n * `false`.\n *\n * @function\n * @sig * -> Boolean\n * @param {Any} x input value\n * @type {Boolean}\n */\nexport const isString = x => typeof(x) == 'string';\n\n/**\n * Check if value is Array.\n *\n * For same argument, if this function returns `true`, functions `isNil`,\n * `isBoolean`, `isInteger`, `isNumber`, `isString`, and `isObject` will return\n * `false`.\n *\n * @function\n * @sig * -> Boolean\n * @param {*} x input value\n * @return {Boolean}\n */\nexport const isArray = Array.isArray;\n\n/**\n * Check if value is Object.\n *\n * For same argument, if this function returns `true`, functions `isNil`,\n * `isBoolean`, `isInteger`, `isNumber`, `isString`, and `isArray` will return\n * `false`.\n *\n * @function\n * @sig * -> Boolean\n * @param {*} x input value\n * @return {Boolean}\n */\nexport const isObject = x => typeof(x) == 'object' &&\n                             !isArray(x) &&\n                             !isNil(x);\n\n/**\n * Strictly parse integer from string\n *\n * If provided string doesn't represent integer value, `NaN` is returned.\n *\n * @function\n * @sig String -> Number\n * @param {String} value\n * @return {Number}\n */\nexport function strictParseInt(value) {\n    if (/^(-|\\+)?([0-9]+)$/.test(value))\n        return Number(value);\n    return NaN;\n}\n\n/**\n * Strictly parse floating point number from string\n *\n * If provided string doesn't represent valid number, `NaN` is returned.\n *\n * @function\n * @sig String -> Number\n * @param {String} value\n * @return {Number}\n */\nexport function strictParseFloat(value) {\n    if (/^(-|\\+)?([0-9]+(\\.[0-9]+)?)$/.test(value))\n        return Number(value);\n    return NaN;\n}\n\n/**\n * Create new deep copy of input value.\n *\n * In case of Objects or Arrays, new instances are created with elements\n * obtained by recursivly calling `clone` in input argument values.\n *\n * @function\n * @sig * -> *\n * @param {*} x value\n * @return {*} copy of value\n */\nexport function clone(x) {\n    if (isArray(x))\n        return Array.from(x, clone);\n    if (isObject(x)) {\n        let ret = {};\n        for (let i in x)\n            ret[i] = clone(x[i]);\n        return ret;\n    }\n    return x;\n}\n\n/**\n * Combine two arrays in single array of pairs\n *\n * The returned array is truncated to the length of the shorter of the two\n * input arrays.\n *\n * @function\n * @sig [a] -> [b] -> [[a,b]]\n * @param {Array} arr1\n * @param {Array} arr2\n * @return {Array}\n */\nexport function zip(arr1, arr2) {\n    return Array.from((function*() {\n        for (let i = 0; i < arr1.length || i < arr2.length; ++i)\n            yield [arr1[i], arr2[i]];\n    })());\n}\n\n/**\n * Convert object to array of key, value pairs\n *\n * @function\n * @sig Object -> [[String,*]]\n * @param {Object} obj\n * @return {Array}\n */\nexport function toPairs(obj) {\n    return Object.entries(obj);\n}\n\n/**\n * Convert array of key, value pairs to object\n *\n * @function\n * @sig [[String,*]] -> Object\n * @param {Array} arr\n * @return {Object}\n */\nexport function fromPairs(arr) {\n    let ret = {};\n    for (let [k, v] of arr)\n        ret[k] = v;\n    return ret;\n}\n\n/**\n * Flatten nested arrays.\n *\n * Create array with same elements as in input array where all elements which\n * are also arrays are replaced with elements of resulting recursive\n * application of flatten function.\n *\n * @function\n * @sig [a] -> [b]\n * @param {Array} arr\n * @return {Array}\n */\nexport function flatten(arr) {\n    return Array.from((function* flatten(x) {\n        if (isArray(x)) {\n            for (let i of x)\n                yield* flatten(i);\n        } else {\n            yield x;\n        }\n    })(arr));\n}\n\n/**\n * Pipe function calls\n *\n * Pipe provides functional composition with reversed order. First function\n * may have any arity and all other functions are called with only single\n * argument (result from previous function application).\n *\n * In case when no function is provided, pipe returns identity function.\n *\n * @function\n * @sig (((a1, a2, ..., an) -> b1), (b1 -> b2), ..., (bm1 -> bm)) -> ((a1, a2, ..., an) -> bm)\n * @param {...Function} fns functions\n * @return {Function}\n */\nexport function pipe(...fns) {\n    if (fns.length < 1)\n        return identity;\n    return function (...args) {\n        let ret = fns[0].apply(this, args);\n        for (let fn of fns.slice(1))\n            ret = fn(ret);\n        return ret;\n    };\n}\n\n/**\n * Apply list of functions to same arguments and return list of results\n *\n * @function\n * @sig ((a1 -> ... -> an -> b1), ..., (a1 -> ... -> an -> bm)) -> (a1 -> ... -> an -> [b1,...,bm])\n * @param {...Function} fns functions\n * @return {Function}\n */\nexport function flap(...fns) {\n    return (...args) => fns.map(fn => fn.apply(this, args));\n}\n\n/**\n * Curry function with fixed arguments lenth\n *\n * Function arity is determined based on function's length property.\n *\n * @function\n * @sig (* -> a) -> (* -> a)\n * @param {Function} fn\n * @return {Function}\n */\nexport function curry(fn) {\n    let wrapper = function(oldArgs) {\n        return function(...args) {\n            args = oldArgs.concat(args);\n            if (args.length >= fn.length)\n                return fn(...args);\n            return wrapper(args);\n        };\n    };\n    return wrapper([]);\n}\n\n/**\n * Deep object equality\n * (curried function)\n *\n * @function\n * @sig a -> b -> Boolean\n * @param {*} x\n * @param {*} y\n * @return {Boolean}\n */\nexport const equals = curry((x, y) => {\n    if (x === y)\n        return true;\n    if (typeof(x) != 'object' ||\n        typeof(y) != 'object' ||\n        x === null ||\n        y === null)\n        return false;\n    if (Array.isArray(x) && Array.isArray(y)) {\n        if (x.length != y.length)\n            return false;\n        for (let [a, b] of zip(x, y)) {\n            if (!equals(a, b))\n                return false;\n        }\n        return true;\n    } else if (!Array.isArray(x) && !Array.isArray(y)) {\n        if (Object.keys(x).length != Object.keys(y).length)\n            return false;\n        for (let key in x) {\n            if (!(key in y))\n                return false;\n        }\n        for (let key in x) {\n            if (!equals(x[key], y[key]))\n                return false;\n        }\n        return true;\n    }\n    return false;\n});\n\n\n/**\n * Create array by repeating same value\n * (curried function)\n *\n * @function\n * @sig a -> Number -> [a]\n * @param {*} x\n * @param {Number} n\n * @return {Array}\n */\nexport const repeat = curry((x, n) => Array.from({length: n}, _ => x));\n\n/**\n * Get value referenced by path\n * (curried function)\n *\n * If input value doesn't contain provided path value, `undefined` is returned.\n *\n * @function\n * @sig Path -> a -> b\n * @param {Path} path\n * @param {*} x\n * @return {*}\n */\nexport const get = curry((path, x) => {\n    let ret = x;\n    for (let i of flatten(path)) {\n        if (ret === null || typeof(ret) != 'object')\n            return undefined;\n        ret = ret[i];\n    }\n    return ret;\n});\n\n/**\n * Change value referenced with path by appling function\n * (curried function)\n *\n * @function\n * @sig Path -> (a -> b) -> c -> c\n * @param {Path} path\n * @param {Function} fn\n * @param {*} x\n * @return {*}\n */\nexport const change = curry((path, fn, x) => {\n    return (function change(path, x) {\n        if (path.length < 1)\n            return fn(x);\n        const [first, ...rest] = path;\n        if (isInteger(first)) {\n            x = (isArray(x) ? Array.from(x) : repeat(undefined, first));\n        } else if (isString(first)) {\n            x = (isObject(x) ? Object.assign({}, x) : {});\n        } else {\n            throw 'invalid path';\n        }\n        x[first] = change(rest, x[first]);\n        return x;\n    })(flatten(path), x);\n});\n\n/**\n * Replace value referenced with path with another value\n * (curried function)\n *\n * @function\n * @sig Path -> (a -> b) -> c -> c\n * @param {Path} path\n * @param {*} val\n * @param {*} x\n * @return {*}\n */\nexport const set = curry((path, val, x) => change(path, _ => val, x));\n\n/**\n * Omitting value referenced by path\n * (curried function)\n *\n * @function\n * @sig Path -> a -> a\n * @param {Path} path\n * @param {*} x\n * @return {*}\n */\nexport const omit = curry((path, x) => {\n    function _omit(path, x) {\n        if (isInteger(path[0])) {\n            x = (isArray(x) ? Array.from(x) : []);\n        } else if (isString(path[0])) {\n            x = (isObject(x) ? Object.assign({}, x) : {});\n        } else {\n            throw 'invalid path';\n        }\n        if (path.length > 1) {\n            x[path[0]] = _omit(path.slice(1), x[path[0]]);\n        } else if (isInteger(path[0])) {\n            x.splice(path[0], 1);\n        } else {\n            delete x[path[0]];\n        }\n        return x;\n    }\n    path = flatten(path);\n    if (path.length < 1)\n        return undefined;\n    return _omit(path, x);\n});\n\n/**\n * Change by moving value from source path to destination path\n * (curried function)\n *\n * @function\n * @sig Path -> Path -> a -> a\n * @param {Path} srcPath\n * @param {Path} dstPath\n * @param {*} x\n * @return {*}\n */\nexport const move = curry((srcPath, dstPath, x) => pipe(\n    set(dstPath, get(srcPath, x)),\n    omit(srcPath)\n)(x));\n\n/**\n * Sort array\n * (curried function)\n *\n * Comparison function receives two arguments representing array elements and\n * should return:\n *   - negative number in case first argument is more significant then second\n *   - zero in case first argument is equaly significant as second\n *   - positive number in case first argument is less significant then second\n *\n * @function\n * @sig ((a, a) -> Number) -> [a] -> [a]\n * @param {Function} fn\n * @param {Array} arr\n * @return {Array}\n */\nexport const sort = curry((fn, arr) => Array.from(arr).sort(fn));\n\n/**\n * Sort array based on results of appling function to it's elements\n * (curried function)\n *\n * Resulting order is determined by comparring function application results\n * with greater then and lesser then operators.\n *\n * @function\n * @sig (a -> b) -> [a] -> [a]\n * @param {Function} fn\n * @param {Array} arr\n * @return {Array}\n */\nexport const sortBy = curry((fn, arr) => sort((x, y) => {\n    const xVal = fn(x);\n    const yVal = fn(y);\n    if (xVal < yVal)\n        return -1;\n    if (xVal > yVal)\n        return 1;\n    return 0;\n}, arr));\n\n/**\n * Create object containing only subset of selected properties\n * (curried function)\n *\n * @function\n * @sig [String] -> a -> a\n * @param {Array} arr\n * @param {Object} obj\n * @return {Object}\n */\nexport const pick = curry((arr, obj) => {\n    const ret = {};\n    for (let i of arr)\n        if (i in obj)\n            ret[i] = obj[i];\n    return ret;\n});\n\n/**\n * Change array or object by appling function to it's elements\n * (curried function)\n *\n * For each element, provided function is called with element value,\n * index/key and original container.\n *\n * @function\n * @sig ((a, Number, [a]) -> b) -> [a] -> [b]\n * @sig ((a, String, {String: a}) -> b) -> {String: a} -> {String: b}\n * @param {Function} fn\n * @param {Array|Object} x\n * @return {Array|Object}\n */\nexport const map = curry((fn, x) => {\n    if (isArray(x))\n        return x.map(fn);\n    const res = {};\n    for (let k in x)\n        res[k] = fn(x[k], k, x);\n    return res;\n});\n\n/**\n * Change array to contain only elements for which function returns `true`\n * (curried function)\n *\n * @function\n * @sig (a -> Boolean) -> [a] -> [a]\n * @param {Function} fn\n * @param {Array} arr\n * @return {Array}\n */\nexport const filter = curry((fn, arr) => arr.filter(fn));\n\n/**\n * Append value to end of array\n * (curried function)\n *\n * @function\n * @sig a -> [a] -> [a]\n * @param {*} val\n * @param {Array} arr\n * @return {Array}\n */\nexport const append = curry((val, arr) => arr.concat([val]));\n\n/**\n * Reduce array values by appling function\n * (curried function)\n *\n * For each array element, provided function is called with accumulator,\n * current value, current index and source array.\n *\n * TODO: support objects\n *\n * @function\n * @sig ((b, a, Number, [a]) -> b) -> b -> [a] -> b\n * @param {Function} fn\n * @param {*} val initial accumulator value\n * @param {Array} arr\n * @return {*} reduced value\n */\nexport const reduce = curry((fn, val, arr) => arr.reduce(fn, val));\n\n/**\n * Merge two objects\n * (curried function)\n *\n * If same property exist in both arguments, second argument's value is used\n * as resulting value\n *\n * @function\n * @sig a -> a -> a\n * @param {Object} x\n * @param {Object} y\n * @return {Object}\n */\nexport const merge = curry((x, y) => Object.assign({}, x, y));\n\n/**\n * Merge multiple objects\n * (curried function)\n *\n * If same property exist in multiple arguments, value from the last argument\n * containing that property is used\n *\n * @function\n * @sig [a] -> a\n * @param {Object[]}\n * @return {Object}\n */\nexport const mergeAll = reduce(merge, {});\n\n/**\n * Find element in array or object for which provided function returns `true`\n * (curried function)\n *\n * Until element is found, provided function is called for each element with\n * arguments: current element, current index/key and initial container.\n *\n * If searched element is not found, `undefined` is returned.\n *\n * @function\n * @sig ((a, Number, [a]) -> Boolean) -> [a] -> a\n * @sig ((a, String, {String: a}) -> Boolean) -> {String: a} -> a\n * @param {Function} fn\n * @param {Array|Object} x\n * @return {*}\n */\nexport const find = curry((fn, x) => {\n    if (isArray(x))\n        return x.find(fn);\n    for (let k in x)\n        if (fn(x[k], k, x))\n            return x[k];\n});\n\n/**\n * Find element's index/key in array or object for which provided function\n * returns `true`\n * (curried function)\n *\n * Until element is found, provided function is called for each element with\n * arguments: current element, current index/key and initial container.\n *\n * If searched element is not found, `undefined` is returned.\n *\n * @function\n * @sig ((a, Number, [a]) -> Boolean) -> [a] -> a\n * @sig ((a, String, {String: a}) -> Boolean) -> {String: a} -> a\n * @param {Function} fn\n * @param {Array|Object} x\n * @return {*}\n */\nexport const findIndex = curry((fn, x) => {\n    if (isArray(x))\n        return x.findIndex(fn);\n    for (let k in x)\n        if (fn(x[k], k, x))\n            return k;\n});\n\n/**\n * Concatenate two arrays\n * (curried function)\n *\n * @function\n * @sig [a] -> [a] -> [a]\n * @param {Array} x\n * @param {Array} y\n * @return {Array}\n */\nexport const concat = curry((x, y) => x.concat(y));\n\n/**\n * Create union of two arrays using `equals` to check equality\n * (curried function)\n *\n * @function\n * @sig [a] -> [a] -> [a]\n * @param {Array} x\n * @param {Array} y\n * @return {Array}\n */\nexport const union = curry((x, y) => {\n    return reduce((acc, val) => {\n        if (!find(equals(val), x))\n            acc = append(val, acc);\n        return acc;\n    }, x, y);\n});\n\n/**\n * Check if array contains value\n * (curried function)\n *\n * TODO: add support for objects (should we check for keys or values?)\n *\n * @function\n * @sig a -> [a] -> Boolean\n * @param {*} val\n * @param {Array|Object} x\n * @return {Boolean}\n */\nexport const contains = curry((val, arr) => arr.includes(val));\n\n/**\n * Insert value into array on specified index\n * (curried function)\n *\n * @function\n * @sig Number -> a -> [a] -> [a]\n * @param {Number} idx\n * @param {*} val\n * @param {Array} arr\n * @return {Array}\n */\nexport const insert = curry((idx, val, arr) =>\n    arr.slice(0, idx).concat([val], arr.slice(idx)));\n\n/**\n * Get array slice\n * (curried function)\n *\n * @function\n * @sig Number -> Number -> [a] -> [a]\n * @param {Number} begin\n * @param {Number} end\n * @param {Array} arr\n * @return {Array}\n */\nexport const slice = curry((begin, end, arr) => arr.slice(begin, end));\n\n/**\n * Reverse array\n *\n * @function\n * @sig [a] -> [a]\n * @param  {Array} arr\n * @return {Array}\n */\nexport function reverse(arr) {\n    return Array.from(arr).reverse();\n}\n\n/**\n * Array length\n *\n * @function\n * @sig [a] -> Number\n * @param  {Array} arr\n * @return {Number}\n */\nexport function length(arr) {\n    return arr.length;\n}\n\n/**\n * Increment value\n * @param  {Number} val\n * @return {Number}\n */\nexport function inc(val) {\n    return val + 1;\n}\n\n/**\n * Decrement value\n * @param  {Number} val\n * @return {Number}\n */\nexport function dec(val) {\n    return val - 1;\n}\n\n/**\n * Logical not\n * @param  {Any} val\n * @return {Boolean}\n */\nexport function not(val) {\n    return !val;\n}\n\n/**\n * Create promise that resolves in `t` milliseconds\n *\n * TODO: move to other module\n *\n * @function\n * @sig Number -> Promise\n * @param {Number} t\n * @return {Promise}\n */\nexport function sleep(t) {\n    return new Promise(resolve => {\n        setTimeout(() => { resolve(); }, t);\n    });\n}\n\n/**\n * Delay function call `fn(...args)` for `t` milliseconds\n *\n * TODO: move to other module\n *\n * @function\n * @sig (((a1, a2, ..., an) -> _), Number, a1, a2, ..., an) -> Promise\n * @param {Function} fn\n * @param {Number} [t=0]\n * @param {*} args\n * @return {Promise}\n */\nexport function delay(fn, t, ...args) {\n    return new Promise(resolve => {\n        setTimeout(() => { resolve(fn(...args)); }, t || 0);\n    });\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import r from '@hat-core/renderer';\n\n\nexport async function init() {\n    await r.set('view', {});\n}\n\n\nexport function vt() {\n    return ['div', 'HELLO WORLD']\n}\n\n\nexport function destroy() {}\n"],"sourceRoot":""}